namespace InputSysUpdateDemo
{
    // https://www.youtube.com/watch?v=UC2sPaYTfEE
    // https://qiita.com/ELIXIR/items/f010873fe77b5d03064d
    using UnityEngine;
    using UnityEngine.InputSystem;

    public class MyPlCtrl : MonoBehaviour
    {
        enum MoveType
        {
            Direct=0, // 直接位置を動かす
            RigidMove, // Rigidbody2Dを使って動かす
            VelocityMove, // Rigidbody2Dの速度を設定して動かす
            ForceMove, // Rigidbody2DのAddForceを使って動かす
        }
        [SerializeField, Tooltip("移動タイプ")] MoveType m_moveType = MoveType.RigidMove; // Choose the movement type in the inspector
        [SerializeField, Tooltip("2D物理演算用")] Rigidbody2D m_rb;

        VenusSamples6_2DSettings m_Actions; //generated by Unity Input System
        VenusSamples6_2DSettings.PlayerActions m_Player;
        Vector2 m_moveVec;

        private void Awake()
        {
            m_Actions = new VenusSamples6_2DSettings(); // 指定したアクションマップを使用
            m_Player = m_Actions.Player;

#if false // 本来の使い方はこんな感じ
            m_Player.Move.performed += OnMove; // Moveキーが実行された時に呼ばれるメソッドを登録
            m_Player.Move.canceled += OnMove; // Moveキーが離された時に呼ばれるメソッドを登録
#endif
        }
        private void OnEnable() =>  m_Actions.Enable(); // Enable the input actions
        private void OnDisable() => m_Actions.Disable(); // Disable the input actions to prevent them from being active when not needed
        private void OnDestroy() => m_Actions.Dispose(); // Clean up the input actions

        // Start is called once before the first execution of Update after the MonoBehaviour is created
        void Start()
        {
            if(m_rb == null)
            {
                m_rb = GetComponent<Rigidbody2D>();
            }
        }

        // Update is called once per frame
        void Update()
        {
        }

        // FixedUpdateは物理演算の更新に使用されるため、Rigidbody2Dを使う場合はここで入力を処理するのが適切
        private void FixedUpdate()
        {
            Vector2 moveInp = m_Player.Move.ReadValue<Vector2>();  // 入力を受け取る

            if (moveInp != Vector2.zero)
            {
                Vector2 deltaVec = moveInp * Time.fixedDeltaTime; // １フレームで進む距離を計算 
                //Debug.Log("deltaVec: " + deltaVec.ToString()); // consoleにデバッグ表示
                switch (m_moveType)
                {
                    case MoveType.Direct: // 直接位置を動かす
                        transform.position += (Vector3)deltaVec;
                        break;
                    case MoveType.RigidMove: // Rigidbody2Dを使って動かす
                        m_rb.MovePosition((Vector2)transform.position + deltaVec);
                        break;
                    case MoveType.VelocityMove: // Rigidbody2Dの速度を設定して動かす
                        m_rb.linearVelocity = moveInp; // Adjust speed as needed
                        break;
                    case MoveType.ForceMove: // Rigidbody2DのAddForceを使って動かす
                        m_rb.AddForce(moveInp * 5f, ForceMode2D.Force); // 値が小さすぎると摩擦で動かないので*10
                        m_rb.linearVelocity = Vector2.ClampMagnitude(m_rb.linearVelocity, 5f); // 最大速度を制限

                        break;

                }
            }
        }

#if false // 本来の使い方はこんな感じ
        // m_Player.Move のキーが押された/離された時に呼ばれる
        public void OnMove(InputAction.CallbackContext context)
        {
            Debug.Log("Move action: " + context.phase.ToString());
            m_moveVec = context.ReadValue<Vector2>();
        }

        // m_Player.Jump のキーが押された時に呼ばれる
        public void OnJumpButton(InputAction.CallbackContext context)
        {
            Debug.Log("press Jump button!" + context.ToString());
            if (context.phase == InputActionPhase.Performed)
            {
                // This is called when the Jump button is pressed
                // You can add your jump logic here
            }
        }
#endif

    }
}
